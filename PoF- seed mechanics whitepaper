Работа кошелька PoF‑Seed: детализированное описание (с уточнениями и дополнениями)

Ниже — полный цикл операций кошелька PoF‑Seed, включая криптографические механизмы, сетевые взаимодействия и меры безопасности.

1. Установка и первичная инициализация

Шаг 1. Загрузка приложения

Пользователь скачивает кошелёк из официального источника:

App Store / Google Play;

сайт GLC (с HTTPS и валидным SSL‑сертификатом).

Проверка целостности:

Сверяет цифровую подпись приложения (через встроенные механизмы ОС).

Сравнивает хеш установочного файла (SHA‑256) с эталонным значением на сайте GLC.

Шаг 2. Запуск и согласие с условиями

При первом запуске:

Отображается лицензионное соглашение (EULA).

Пользователь подтверждает согласие.

Активируется режим «PoF‑Seed» (по умолчанию).

Шаг 3. Генерация VRF‑ключей

Кошелёк создаёт пару ключей на кривой Ed25519:

sk∈Zq(приватный ключ),pk=gsk(публичный ключ)

Хранение sk:

Только в защищённой памяти устройства:

iOS: Secure Enclave;

Android: Android Keystore (с аппаратной защитой, если доступно).

Запрещён экспорт sk в незашифрованном виде.

2. Регистрация в сети

Шаг 4. Отправка pk в PoF‑Registry

Кошелёк формирует транзакцию:

json

{ "action": "register", "pk": "<hex-строка pk>", "timestamp": <unix-время> } 

Транзакция подписывается sk (ECDSA на Ed25519).

Отправляется в сеть GLC через P2P‑узел.

Шаг 5. Получение ID_u

PoF‑Registry:

Проверяет подпись транзакции (через pk).

Генерирует ID_u как UUIDv4.

Сохраняет пару (ID_u, pk) в хранилище.

Ответ: событие блокчейна PoF_Registered(ID_u, pk).

Шаг 6. Запись на NFC‑карту

Пользователь подносит карту к устройству.

Кошелёк:

Сканирует биометрию → получает шаблон B.

Генерирует мастер‑ключ ключ_NFC (256 бит, через CSPRNG).

Шифрует B:

B_enc=AES_256_GCM(B,ключ_NFC)

Записывает на карту:

B_enc (зашифрованный биометрический шаблон);

ID_u;

ЭЦП (ID_u, подписанная sk).

Подтверждение:

Вибрация/звук;

Сообщение: «Карта успешно зарегистрирована».

3. Генерация ключа для транзакции

Сценарий: отправка 5 GLC.

Шаг 7. Ввод данных

Адрес получателя и сумма вводятся:

вручную;

через сканирование QR‑кода.

Шаг 8. Запрос параметров генерации

Кошелёк отправляет в PoF‑Registry запрос:

json

{ "action": "get_params", "ID_u": "<ID_u пользователя>", "purpose": "tx_sign" } 

Ответ из блокчейна:

json

{ "N": 15, "dictionary_hash": "0xabc123...", "selection_rule": 0, "vrf_seed": "0xdef456...", "round_id": 12345 } 

Шаг 9. Повторная биометрия

Кошелёк блокирует операцию до сканирования:

отпечаток пальца или Face ID.

Получает B''.

Сравнивает B'' с B (первым шаблоном):

Если совпадают (с допуском на шум сенсора) → переход к шагу 10.

Иначе → ошибка: «Биометрия не подтверждена».

Шаг 10. Сбор VRF‑ответов от сети

Кошелёк транслирует в P2P‑сеть:

json

{ "round_id": 12345, "vrf_seed": "0xdef456...", "pk": "<pk кошелька>" } 

Участники сети отвечают (vrf_output_i, proof_i).

Кошелёк ждёт ответов от 3 валидаторов (кворум).

Для каждого ответа:

Проверяет proof_i через pk_i из PoF‑Registry.

Сохраняет валидные vrf_output_i.

Шаг 11. Вычисление R

R=SHA‑256локальный выходvrf_output_local∥XOR трёх выходов(i=1⨁3vrf_outputi)∥идентификатор раундаround_id

vrf_output_local — локальный выход кошелька (сгенерирован на sk).

⊕ — операция XOR над тремя vrf_output_i.

round_id — идентификатор раунда.

Шаг 12. Синтез Seed

Для каждого k от 1 до N:

ik=(Hash(B”∥R∥k)mod2048)

Выбирается слово w_{i_k} из словаря (по dictionary_hash).

Формируется Seed = [w_{i_1}, \ldots, w_{i_{15}}].

Шаг 13. Генерация ключа K

K=PBKDF2(Seed,соль,100000 итераций,SHA‑512)

Соль: ID_u || round_id.

Ключ K используется для подписи транзакции.

Шаг 14. Подпись и отправка

Транзакция хешируется: tx_hash = SHA‑256(tx_data).

Подписывается: signature = \text{ECDSA\_sign}(tx_hash, K).

Отправляется в сеть GLC.

Шаг 15. Очистка памяти
Сразу после отправки:

Seed перезаписывается нулями.

R, B'', vrf_output_i удаляются из RAM.

Временные буферы очищаются через API ОС (например, SecureZeroMemory на Windows).

4. Восстановление доступа через NFC

Сценарий: утеря устройства, переустановка приложения.

Шаг 16. Запуск восстановления

В приложении: кнопка «Восстановить через NFC

Шаг 17. Считывание карты (детализация)

Пользователь подносит NFC‑карту к устройству.

Кошелёк инициирует сеанс NFC (стандарт ISO/IEC 14443 или NDEF).

Получает данные с карты:

B_enc — зашифрованный биометрический шаблон (AES‑256‑GCM);

ID_u — уникальный идентификатор пользователя (UUIDv4);

ЭЦП — подпись ID_u, созданная приватным ключом кошелька (sk) при регистрации.

Проверяет ЭЦП:

запрашивает pk пользователя из PoF‑Registry по ID_u;

верифицирует подпись через ECDSA (на кривой Ed25519);

если проверка не пройдена → ошибка: «Неверная подпись карты».

Шаг 18. Расшифровка B

Кошелёк извлекает ключ_NFC из защищённой памяти (Secure Enclave/Keystore).

Расшифровывает B_enc:

B=AES_256_GCM_decrypt(B_enc,ключ_NFC)

Если расшифровка неудачна (например, из‑за повреждённой карты или неверного ключа) → ошибка: «Ошибка расшифровки биометрии».

Сохраняет B в оперативной памяти (временно, для сравнения).

Шаг 19. Биометрическая верификация

Кошелёк запрашивает повторное сканирование биометрии:

отпечаток пальца или Face ID.

Получает новый шаблон B''' (с учётом естественного шума сенсора).

Сравнивает B''' с сохранённым B:

используется алгоритм схожести биометрических шаблонов (например, расстояние Хэмминга или косинусное сходство);

порог допуска: ±5 % (настраивается в зависимости от типа биометрии);

если сходство ниже порога → ошибка: «Биометрия не подтверждена».

При успешном сравнении:

освобождает память от B''';

переходит к шагу 20.

Шаг 20. Повторный синтез Seed
Повторяются шаги 8–13 из раздела «Генерация ключа для транзакции»:

Запрос параметров генерации

Кошелёк отправляет в PoF‑Registry:

json

{ "action": "get_params", "ID_u": "<ID_u>", "purpose": "recovery" } 

Получает ответ: N, dictionary_hash, selection_rule, vrf_seed, round_id.

Сбор VRF‑ответов

Транслирует в P2P‑сеть запрос с round_id и vrf_seed.

Ждёт 3 валидных ответа (vrf_output_i, proof_i).

Проверяет каждый proof_i через pk_i из PoF‑Registry.

Вычисление R

R=SHA‑256(vrf_output_local∥(i=1⨁3vrf_outputi)∥round_id)

Синтез Seed

Для k = 1 до N:

ik=(Hash(B∥R∥k)mod2048)

Выбираются слова w_{i_k} из словаря (по dictionary_hash).

Формируется Seed = [w_{i_1}, \ldots, w_{i_{15}}].

Генерация ключа K

K=PBKDF2(Seed,IDu∥round_id,100000,SHA‑512)

Шаг 21. Доступ восстановлен

Кошелёк:

сохраняет K в защищённой памяти;

загружает баланс и историю транзакций из блокчейна GLC (по ID_u);

активирует все функции (отправка, получение, участие в PoF‑раундах).

Пользователь видит:

текущий баланс;

список последних транзакций;

статус участия в PoF (если на балансе ≥ 10 GLC).

Очистка памяти:

временные буферы (B, R, промежуточные хеши) удаляются через API ОС;

Seed перезаписывается нулями.

5. Участие в PoF‑раундах (опционально)

Условие: баланс ≥ 10 GLC.
Шаг 22. Активация режима

В приложении: «Участвовать в PoF‑раундах».

Кошелёк:

проверяет баланс через PoF‑Registry;

регистрирует участника в текущем раунде (транзакция с ID_u и отметкой status=active).

Шаг 23. Генерация vrf_output для раунда

Получает vrf_seed из PoF‑Registry (общий для раунда).

Вычисляет:

(vrf_output,proof)=VRF(sk,vrf_seed)

Отправляет (vrf_output, proof) в сеть GLC.

Шаг 24. Ожидание результата

PoF‑Registry определяет победителя раунда (минимальный vrf_output).

Если кошелёк победил:

получает вознаграждение (GLC);

участвует в генерации параметров следующего раунда.

Если не победил:

остаётся в пуле участников для следующего раунда.

Шаг 25. Деактивация участия

Пользователь отключает режим через приложение.

Кошелёк отправляет транзакцию status=inactive.

Участник исключается из текущего раунда.

Ключевые меры безопасности

Защита приватных ключей

sk хранится только в Secure Enclave/Keystore.

Запрещён экспорт sk в открытом виде.

Биометрическая защита

Шаблоны (B) шифруются перед записью на NFC‑карту.

Сравнение шаблонов использует допуски на шум сенсора.

Очистка памяти

Временные данные (Seed, R, B'') удаляются сразу после использования.

Используется API ОС для гарантированного обнуления буферов.

Верификация данных

Все proof_i проверяются через pk_i.

vrf_seed и round_id берутся из блокчейна (неподделываемы).

Защита от атак

Кворум из 3 участников снижает риск манипуляций с R.

Случайный отбор участников исключает предвзятость.
